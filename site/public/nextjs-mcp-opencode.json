{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "nextjs-mcp-opencode",
  "type": "registry:item",
  "title": "Next.js MCP (OpenCode)",
  "description": "Merge the Next.js DevTools MCP server into opencode.json/jsonc.",
  "meta": {
    "concept": "nextjs-mcp",
    "platform": "opencode",
    "kind": [
      "mcp",
      "config",
      "script"
    ],
    "postInstall": "node .opencode/bin/merge-mcp.mjs",
    "installPath": "nextjs-mcp-opencode.v1.json"
  },
  "files": [
    {
      "path": "registry/nextjs-mcp/opencode/files/bin/merge-mcp.mjs",
      "type": "registry:file",
      "target": "~/.opencode/bin/merge-mcp.mjs",
      "content": "#!/usr/bin/env node\nimport { createRequire } from \"node:module\";\nvar __create = Object.create;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __toESM = (mod, isNodeMode, target) => {\n  target = mod != null ? __create(__getProtoOf(mod)) : {};\n  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target;\n  for (let key of __getOwnPropNames(mod))\n    if (!__hasOwnProp.call(to, key))\n      __defProp(to, key, {\n        get: () => mod[key],\n        enumerable: true\n      });\n  return to;\n};\nvar __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);\nvar __require = /* @__PURE__ */ createRequire(import.meta.url);\n\n// node_modules/.bun/jsonc-parser@3.3.1/node_modules/jsonc-parser/lib/umd/main.js\nvar require_main = __commonJS((exports, module) => {\n  (function(factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n      var v = factory(__require, exports);\n      if (v !== undefined)\n        module.exports = v;\n    } else if (typeof define === \"function\" && define.amd) {\n      define([\"require\", \"exports\", \"./impl/format\", \"./impl/edit\", \"./impl/scanner\", \"./impl/parser\"], factory);\n    }\n  })(function(require2, exports2) {\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.applyEdits = exports2.modify = exports2.format = exports2.printParseErrorCode = exports2.ParseErrorCode = exports2.stripComments = exports2.visit = exports2.getNodeValue = exports2.getNodePath = exports2.findNodeAtOffset = exports2.findNodeAtLocation = exports2.parseTree = exports2.parse = exports2.getLocation = exports2.SyntaxKind = exports2.ScanError = exports2.createScanner = undefined;\n    const formatter = require2(\"./impl/format\");\n    const edit = require2(\"./impl/edit\");\n    const scanner = require2(\"./impl/scanner\");\n    const parser = require2(\"./impl/parser\");\n    exports2.createScanner = scanner.createScanner;\n    var ScanError;\n    (function(ScanError2) {\n      ScanError2[ScanError2[\"None\"] = 0] = \"None\";\n      ScanError2[ScanError2[\"UnexpectedEndOfComment\"] = 1] = \"UnexpectedEndOfComment\";\n      ScanError2[ScanError2[\"UnexpectedEndOfString\"] = 2] = \"UnexpectedEndOfString\";\n      ScanError2[ScanError2[\"UnexpectedEndOfNumber\"] = 3] = \"UnexpectedEndOfNumber\";\n      ScanError2[ScanError2[\"InvalidUnicode\"] = 4] = \"InvalidUnicode\";\n      ScanError2[ScanError2[\"InvalidEscapeCharacter\"] = 5] = \"InvalidEscapeCharacter\";\n      ScanError2[ScanError2[\"InvalidCharacter\"] = 6] = \"InvalidCharacter\";\n    })(ScanError || (exports2.ScanError = ScanError = {}));\n    var SyntaxKind;\n    (function(SyntaxKind2) {\n      SyntaxKind2[SyntaxKind2[\"OpenBraceToken\"] = 1] = \"OpenBraceToken\";\n      SyntaxKind2[SyntaxKind2[\"CloseBraceToken\"] = 2] = \"CloseBraceToken\";\n      SyntaxKind2[SyntaxKind2[\"OpenBracketToken\"] = 3] = \"OpenBracketToken\";\n      SyntaxKind2[SyntaxKind2[\"CloseBracketToken\"] = 4] = \"CloseBracketToken\";\n      SyntaxKind2[SyntaxKind2[\"CommaToken\"] = 5] = \"CommaToken\";\n      SyntaxKind2[SyntaxKind2[\"ColonToken\"] = 6] = \"ColonToken\";\n      SyntaxKind2[SyntaxKind2[\"NullKeyword\"] = 7] = \"NullKeyword\";\n      SyntaxKind2[SyntaxKind2[\"TrueKeyword\"] = 8] = \"TrueKeyword\";\n      SyntaxKind2[SyntaxKind2[\"FalseKeyword\"] = 9] = \"FalseKeyword\";\n      SyntaxKind2[SyntaxKind2[\"StringLiteral\"] = 10] = \"StringLiteral\";\n      SyntaxKind2[SyntaxKind2[\"NumericLiteral\"] = 11] = \"NumericLiteral\";\n      SyntaxKind2[SyntaxKind2[\"LineCommentTrivia\"] = 12] = \"LineCommentTrivia\";\n      SyntaxKind2[SyntaxKind2[\"BlockCommentTrivia\"] = 13] = \"BlockCommentTrivia\";\n      SyntaxKind2[SyntaxKind2[\"LineBreakTrivia\"] = 14] = \"LineBreakTrivia\";\n      SyntaxKind2[SyntaxKind2[\"Trivia\"] = 15] = \"Trivia\";\n      SyntaxKind2[SyntaxKind2[\"Unknown\"] = 16] = \"Unknown\";\n      SyntaxKind2[SyntaxKind2[\"EOF\"] = 17] = \"EOF\";\n    })(SyntaxKind || (exports2.SyntaxKind = SyntaxKind = {}));\n    exports2.getLocation = parser.getLocation;\n    exports2.parse = parser.parse;\n    exports2.parseTree = parser.parseTree;\n    exports2.findNodeAtLocation = parser.findNodeAtLocation;\n    exports2.findNodeAtOffset = parser.findNodeAtOffset;\n    exports2.getNodePath = parser.getNodePath;\n    exports2.getNodeValue = parser.getNodeValue;\n    exports2.visit = parser.visit;\n    exports2.stripComments = parser.stripComments;\n    var ParseErrorCode;\n    (function(ParseErrorCode2) {\n      ParseErrorCode2[ParseErrorCode2[\"InvalidSymbol\"] = 1] = \"InvalidSymbol\";\n      ParseErrorCode2[ParseErrorCode2[\"InvalidNumberFormat\"] = 2] = \"InvalidNumberFormat\";\n      ParseErrorCode2[ParseErrorCode2[\"PropertyNameExpected\"] = 3] = \"PropertyNameExpected\";\n      ParseErrorCode2[ParseErrorCode2[\"ValueExpected\"] = 4] = \"ValueExpected\";\n      ParseErrorCode2[ParseErrorCode2[\"ColonExpected\"] = 5] = \"ColonExpected\";\n      ParseErrorCode2[ParseErrorCode2[\"CommaExpected\"] = 6] = \"CommaExpected\";\n      ParseErrorCode2[ParseErrorCode2[\"CloseBraceExpected\"] = 7] = \"CloseBraceExpected\";\n      ParseErrorCode2[ParseErrorCode2[\"CloseBracketExpected\"] = 8] = \"CloseBracketExpected\";\n      ParseErrorCode2[ParseErrorCode2[\"EndOfFileExpected\"] = 9] = \"EndOfFileExpected\";\n      ParseErrorCode2[ParseErrorCode2[\"InvalidCommentToken\"] = 10] = \"InvalidCommentToken\";\n      ParseErrorCode2[ParseErrorCode2[\"UnexpectedEndOfComment\"] = 11] = \"UnexpectedEndOfComment\";\n      ParseErrorCode2[ParseErrorCode2[\"UnexpectedEndOfString\"] = 12] = \"UnexpectedEndOfString\";\n      ParseErrorCode2[ParseErrorCode2[\"UnexpectedEndOfNumber\"] = 13] = \"UnexpectedEndOfNumber\";\n      ParseErrorCode2[ParseErrorCode2[\"InvalidUnicode\"] = 14] = \"InvalidUnicode\";\n      ParseErrorCode2[ParseErrorCode2[\"InvalidEscapeCharacter\"] = 15] = \"InvalidEscapeCharacter\";\n      ParseErrorCode2[ParseErrorCode2[\"InvalidCharacter\"] = 16] = \"InvalidCharacter\";\n    })(ParseErrorCode || (exports2.ParseErrorCode = ParseErrorCode = {}));\n    function printParseErrorCode(code) {\n      switch (code) {\n        case 1:\n          return \"InvalidSymbol\";\n        case 2:\n          return \"InvalidNumberFormat\";\n        case 3:\n          return \"PropertyNameExpected\";\n        case 4:\n          return \"ValueExpected\";\n        case 5:\n          return \"ColonExpected\";\n        case 6:\n          return \"CommaExpected\";\n        case 7:\n          return \"CloseBraceExpected\";\n        case 8:\n          return \"CloseBracketExpected\";\n        case 9:\n          return \"EndOfFileExpected\";\n        case 10:\n          return \"InvalidCommentToken\";\n        case 11:\n          return \"UnexpectedEndOfComment\";\n        case 12:\n          return \"UnexpectedEndOfString\";\n        case 13:\n          return \"UnexpectedEndOfNumber\";\n        case 14:\n          return \"InvalidUnicode\";\n        case 15:\n          return \"InvalidEscapeCharacter\";\n        case 16:\n          return \"InvalidCharacter\";\n      }\n      return \"<unknown ParseErrorCode>\";\n    }\n    exports2.printParseErrorCode = printParseErrorCode;\n    function format(documentText, range, options) {\n      return formatter.format(documentText, range, options);\n    }\n    exports2.format = format;\n    function modify(text, path, value, options) {\n      return edit.setProperty(text, path, value, options);\n    }\n    exports2.modify = modify;\n    function applyEdits(text, edits) {\n      let sortedEdits = edits.slice(0).sort((a, b) => {\n        const diff = a.offset - b.offset;\n        if (diff === 0) {\n          return a.length - b.length;\n        }\n        return diff;\n      });\n      let lastModifiedOffset = text.length;\n      for (let i = sortedEdits.length - 1;i >= 0; i--) {\n        let e = sortedEdits[i];\n        if (e.offset + e.length <= lastModifiedOffset) {\n          text = edit.applyEdit(text, e);\n        } else {\n          throw new Error(\"Overlapping edit\");\n        }\n        lastModifiedOffset = e.offset;\n      }\n      return text;\n    }\n    exports2.applyEdits = applyEdits;\n  });\n});\n\n// scripts/merge-mcp.ts\nvar import_jsonc_parser = __toESM(require_main(), 1);\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nvar args = process.argv.slice(2);\nvar options = {\n  keep: false,\n  force: false\n};\nvar payloadArgs = [];\nfor (const arg of args) {\n  if (arg === \"--keep\") {\n    options.keep = true;\n    continue;\n  }\n  if (arg === \"--force\") {\n    options.force = true;\n    continue;\n  }\n  if (arg.startsWith(\"-\")) {\n    console.error(`Unknown option: ${arg}`);\n    process.exit(1);\n  }\n  payloadArgs.push(arg);\n}\nfunction detectEol(text) {\n  return text.includes(`\\r\n`) ? `\\r\n` : `\n`;\n}\nfunction parseJsonc(text, label) {\n  const errors = [];\n  const data = import_jsonc_parser.parse(text, errors, { allowTrailingComma: true, disallowComments: false });\n  if (errors.length) {\n    const first = errors[0];\n    throw new Error(`Failed to parse ${label} at offset ${first.offset}.`);\n  }\n  if (!data || typeof data !== \"object\") {\n    throw new Error(`Expected ${label} to be an object.`);\n  }\n  return data;\n}\nfunction readPayload(filePath) {\n  const raw = fs.readFileSync(filePath, \"utf8\");\n  const data = parseJsonc(raw, filePath);\n  return data;\n}\nfunction resolvePayloads(cwd, explicit) {\n  if (explicit.length) {\n    return explicit.map((item) => path.resolve(cwd, item));\n  }\n  const payloadDir = path.join(cwd, \".opencode\", \"mcp\");\n  if (!fs.existsSync(payloadDir)) {\n    return [];\n  }\n  const entries = fs.readdirSync(payloadDir, { withFileTypes: true });\n  return entries.filter((entry) => entry.isFile() && (entry.name.endsWith(\".json\") || entry.name.endsWith(\".jsonc\"))).map((entry) => path.join(payloadDir, entry.name));\n}\nfunction getConfigPath(cwd) {\n  const jsoncPath = path.join(cwd, \"opencode.jsonc\");\n  if (fs.existsSync(jsoncPath))\n    return jsoncPath;\n  return path.join(cwd, \"opencode.json\");\n}\nfunction ensureDir(dirPath) {\n  fs.mkdirSync(dirPath, { recursive: true });\n}\nfunction main() {\n  const cwd = process.cwd();\n  const payloadFiles = resolvePayloads(cwd, payloadArgs);\n  if (!payloadFiles.length) {\n    console.log(\"No MCP payloads found. Nothing to merge.\");\n    return;\n  }\n  const payloads = payloadFiles.map((filePath) => ({ filePath, payload: readPayload(filePath) }));\n  const mcpEntries = [];\n  for (const { filePath, payload } of payloads) {\n    if (!payload.mcp || typeof payload.mcp !== \"object\") {\n      console.warn(`Skipping ${filePath}: missing mcp object.`);\n      continue;\n    }\n    for (const [name, entry] of Object.entries(payload.mcp)) {\n      if (!entry || typeof entry !== \"object\") {\n        console.warn(`Skipping ${filePath}: mcp.${name} is not an object.`);\n        continue;\n      }\n      mcpEntries.push([name, entry]);\n    }\n  }\n  if (!mcpEntries.length) {\n    console.log(\"No valid MCP entries found. Nothing to merge.\");\n    return;\n  }\n  const configPath = getConfigPath(cwd);\n  const configExists = fs.existsSync(configPath);\n  let configText = configExists ? fs.readFileSync(configPath, \"utf8\") : `{}\n`;\n  const eol = detectEol(configText);\n  const configData = parseJsonc(configText, path.basename(configPath));\n  const existingMcp = configData.mcp && typeof configData.mcp === \"object\" ? configData.mcp : {};\n  const added = [];\n  const skipped = [];\n  const updated = [];\n  for (const [name, entry] of mcpEntries) {\n    const exists = Object.prototype.hasOwnProperty.call(existingMcp, name);\n    if (exists && !options.force) {\n      skipped.push(name);\n      continue;\n    }\n    const edits = import_jsonc_parser.modify(configText, [\"mcp\", name], entry, {\n      formattingOptions: {\n        insertSpaces: true,\n        tabSize: 2,\n        eol\n      }\n    });\n    if (edits.length) {\n      configText = import_jsonc_parser.applyEdits(configText, edits);\n    }\n    if (exists) {\n      updated.push(name);\n    } else {\n      added.push(name);\n    }\n  }\n  if (added.length || updated.length) {\n    const normalized = configText.endsWith(eol) ? configText : `${configText}${eol}`;\n    fs.writeFileSync(configPath, normalized, \"utf8\");\n    console.log(`Updated ${path.basename(configPath)}.`);\n  } else {\n    console.log(`No changes needed in ${path.basename(configPath)}.`);\n  }\n  if (!options.keep) {\n    const payloadDir = path.join(cwd, \".opencode\", \"mcp\");\n    const appliedDir = path.join(payloadDir, \".applied\");\n    ensureDir(appliedDir);\n    for (const filePath of payloadFiles) {\n      const relative = path.relative(payloadDir, filePath);\n      if (relative.startsWith(\"..\") || relative.startsWith(`.${path.sep}`)) {\n        continue;\n      }\n      if (relative.startsWith(`.applied${path.sep}`)) {\n        continue;\n      }\n      const baseName = path.basename(filePath);\n      let target = path.join(appliedDir, baseName);\n      if (fs.existsSync(target)) {\n        const stamp = Date.now();\n        target = path.join(appliedDir, `${baseName}.${stamp}`);\n      }\n      fs.renameSync(filePath, target);\n    }\n  }\n  if (added.length) {\n    console.log(`Added MCP servers: ${added.join(\", \")}`);\n  }\n  if (updated.length) {\n    console.log(`Updated MCP servers: ${updated.join(\", \")}`);\n  }\n  if (skipped.length) {\n    console.log(`Skipped existing MCP servers: ${skipped.join(\", \")}`);\n  }\n}\ntry {\n  main();\n} catch (error) {\n  const message = error instanceof Error ? error.message : String(error);\n  console.error(`MCP merge failed: ${message}`);\n  process.exit(1);\n}\n"
    },
    {
      "path": "registry/nextjs-mcp/opencode/files/mcp/next-devtools.json",
      "type": "registry:file",
      "target": "~/.opencode/mcp/next-devtools.json",
      "content": "{\n  \"mcp\": {\n    \"next-devtools\": {\n      \"type\": \"local\",\n      \"command\": [\"npx\", \"-y\", \"next-devtools-mcp@latest\"],\n      \"enabled\": true\n    }\n  }\n}\n"
    }
  ],
  "docs": "After install, run `node .opencode/bin/merge-mcp.mjs` to merge the MCP config into opencode.json/jsonc. Requires Next.js 16+. The merge script archives payloads in .opencode/mcp/.applied to avoid re-adding removed MCPs."
}
